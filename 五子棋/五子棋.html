<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋人机对战 - 延边ABC游戏协会</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5dc;
            margin: 0;
            padding: 20px;
        }
        
        .association-header {
            font-size: 24px;
            color: #8B4513;
            margin-bottom: 5px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #8B4513;
            margin-top: 0;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        .game-info {
            margin-bottom: 20px;
            font-size: 18px;
            color: #333;
            background: rgba(255,255,255,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .score-board {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.8);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .score-item {
            text-align: center;
            font-size: 16px;
            color: #333;
        }
        
        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #8B4513;
            margin-top: 5px;
        }
        
        .board-container {
            position: relative;
            margin-bottom: 20px;
        }
        
        #board {
            background-color: #dcb35c;
            border: 3px solid #8B4513;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .button-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(to right, #8B4513, #A0522D);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
            font-weight: bold;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 8px rgba(0,0,0,0.3);
        }
        
        .music-btn {
            background: linear-gradient(to right, #4CAF50, #45a049);
        }
        
        .music-btn.playing {
            background: linear-gradient(to right, #f44336, #da190b);
        }
        
        .win-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .win-message {
            background: linear-gradient(135deg, #fff, #f0f0f0);
            padding: 40px 60px;
            border-radius: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #8B4513;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            border: 3px solid #8B4513;
            animation: winPopup 0.5s ease-out;
            max-width: 80%;
        }
        
        @keyframes winPopup {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .win-details {
            margin-top: 20px;
            font-size: 18px;
            color: #666;
        }
        
        .win-score {
            margin-top: 15px;
            font-size: 20px;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .mode-selector {
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        select {
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 30px;
            border: 2px solid #8B4513;
            background-color: white;
            cursor: pointer;
        }
        
        .association-footer {
            margin-top: 20px;
            font-size: 16px;
            color: #8B4513;
            font-style: italic;
        }
        
        .music-info {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- 添加音频标签，假设音乐文件名为 background.mp3，需将其放在项目目录下 -->
    <audio id="background-music" src="background.mp3" loop autoplay></audio> 
    <div class="association-header">延边ABC游戏协会</div>
    <h1>五子棋人机对战</h1>
    
    <div class="mode-selector">
        <div>
            <select id="game-mode">
                <option value="human-first">玩家先手(黑棋)</option>
                <option value="ai-first">电脑先手(白棋)</option>
            </select>
        </div>
    </div>
    
    <div class="score-board">
        <div class="score-item">
            <div>玩家得分</div>
            <div class="score-value" id="player-score">0</div>
        </div>
        <div class="score-item">
            <div>电脑得分</div>
            <div class="score-value" id="ai-score">0</div>
        </div>
        <div class="score-item">
            <div>平局次数</div>
            <div class="score-value" id="draw-score">0</div>
        </div>
    </div>
    
    <div class="game-info">
        当前玩家: <span id="current-player">黑棋</span>
    </div>
    
    <div class="board-container">
        <canvas id="board" width="450" height="450"></canvas>
    </div>
    
    <!-- 获胜弹窗 -->
    <div class="win-overlay" id="win-overlay">
        <div class="win-message" id="win-message">
            <div id="win-text"></div>
            <div class="win-details" id="win-details"></div>
            <div class="win-score" id="win-score"></div>
        </div>
    </div>
    
    <div class="controls">
        <div class="button-row">
            <button id="restart-btn">重新开始</button>
            <button id="music-btn" class="music-btn">🎵 播放音乐</button>
            <button id="reset-score-btn">重置分数</button>
        </div>
        <div class="music-info">
            点击按钮控制背景音乐播放/暂停
        </div>
    </div>
    
    <div class="association-footer">延边ABC游戏协会 荣誉出品</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const currentPlayerDisplay = document.getElementById('current-player');
            const restartBtn = document.getElementById('restart-btn');
            const resetScoreBtn = document.getElementById('reset-score-btn');
            const musicBtn = document.getElementById('music-btn');
            const winOverlay = document.getElementById('win-overlay');
            const winText = document.getElementById('win-text');
            const winDetails = document.getElementById('win-details');
            const winScore = document.getElementById('win-score');
            const gameModeSelect = document.getElementById('game-mode');
            
            // 计分元素
            const playerScoreElement = document.getElementById('player-score');
            const aiScoreElement = document.getElementById('ai-score');
            const drawScoreElement = document.getElementById('draw-score');
            
            // 音频元素
            const backgroundMusic = document.getElementById('background-music');
            const pieceSound = document.getElementById('piece-sound');
            const winSound = document.getElementById('win-sound');
            
            const BOARD_SIZE = 15;
            const CELL_SIZE = canvas.width / BOARD_SIZE;
            const PIECE_RADIUS = CELL_SIZE * 0.4;
            
            let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            let currentPlayer = 1; // 1 for black (human), 2 for white (AI)
            let gameOver = false;
            let gameMode = 'human-first';
            let musicPlaying = false;
            
            // 计分系统
            let playerScore = parseInt(localStorage.getItem('playerScore')) || 0;
            let aiScore = parseInt(localStorage.getItem('aiScore')) || 0;
            let drawScore = parseInt(localStorage.getItem('drawScore')) || 0;
            
            // 更新分数显示
            function updateScoreDisplay() {
                playerScoreElement.textContent = playerScore;
                aiScoreElement.textContent = aiScore;
                drawScoreElement.textContent = drawScore;
            }
            
            // 保存分数到本地存储
            function saveScores() {
                localStorage.setItem('playerScore', playerScore);
                localStorage.setItem('aiScore', aiScore);
                localStorage.setItem('drawScore', drawScore);
            }
            
            // 重置分数
            function resetScores() {
                playerScore = 0;
                aiScore = 0;
                drawScore = 0;
                updateScoreDisplay();
                saveScores();
            }
            
            // 音乐控制
            function toggleMusic() {
                if (musicPlaying) {
                    backgroundMusic.pause();
                    musicBtn.textContent = '🎵 播放音乐';
                    musicBtn.classList.remove('playing');
                    musicPlaying = false;
                } else {
                    // 创建简单的音调作为背景音乐
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime + 0.5);
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 1);
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 1.5);
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 2);
                    
                    musicBtn.textContent = '🔇 暂停音乐';
                    musicBtn.classList.add('playing');
                    musicPlaying = true;
                }
            }
            
            // 播放落子音效
            function playPieceSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.log('音效播放失败:', e);
                }
            }
            
            // 播放获胜音效
            function playWinSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // 播放胜利音调
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.4);
                    oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime + 0.6);
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.6);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.8);
                } catch (e) {
                    console.log('获胜音效播放失败:', e);
                }
            }
            
            // 初始化棋盘
            function initBoard() {
                // 绘制棋盘背景
                ctx.fillStyle = '#dcb35c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制网格线
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // 横线
                    ctx.beginPath();
                    ctx.moveTo(CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                    ctx.lineTo(canvas.width - CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                    ctx.stroke();
                    
                    // 竖线
                    ctx.beginPath();
                    ctx.moveTo(i * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 2);
                    ctx.lineTo(i * CELL_SIZE + CELL_SIZE / 2, canvas.height - CELL_SIZE / 2);
                    ctx.stroke();
                }
                
                // 绘制五个小点（天元等）
                const dots = [
                    [3, 3], [3, 11], [7, 7], [11, 3], [11, 11]
                ];
                
                ctx.fillStyle = '#000';
                dots.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(
                        x * CELL_SIZE + CELL_SIZE / 2,
                        y * CELL_SIZE + CELL_SIZE / 2,
                        CELL_SIZE * 0.1,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }
            
            // 绘制棋子
            function drawPiece(x, y, player) {
                const gradient = ctx.createRadialGradient(
                    x * CELL_SIZE + CELL_SIZE / 2 - PIECE_RADIUS / 3,
                    y * CELL_SIZE + CELL_SIZE / 2 - PIECE_RADIUS / 3,
                    PIECE_RADIUS * 0.1,
                    x * CELL_SIZE + CELL_SIZE / 2,
                    y * CELL_SIZE + CELL_SIZE / 2,
                    PIECE_RADIUS
                );
                
                if (player === 1) { // 黑棋
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#000');
                } else { // 白棋
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(1, '#ddd');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(
                    x * CELL_SIZE + CELL_SIZE / 2,
                    y * CELL_SIZE + CELL_SIZE / 2,
                    PIECE_RADIUS,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // 棋子边缘
                ctx.strokeStyle = player === 1 ? '#333' : '#999';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // 检查是否平局
            function checkDraw() {
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (board[y][x] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // 显示获胜信息
            function showWinMessage(winner, player) {
                winText.textContent = `${winner}获胜！`;
                winDetails.textContent = player === 1 ? '恭喜玩家获得胜利！' : '电脑技高一筹！';
                
                // 更新分数
                if (player === 1) {
                    playerScore++;
                    winScore.textContent = `玩家得分: ${playerScore}`;
                } else {
                    aiScore++;
                    winScore.textContent = `电脑得分: ${aiScore}`;
                }
                
                saveScores();
                updateScoreDisplay();
                
                winOverlay.style.display = 'flex';
                
                // 播放获胜音效
                playWinSound();
            }
            
            // 显示平局信息
            function showDrawMessage() {
                winText.textContent = '平局！';
                winDetails.textContent = '棋逢对手，势均力敌！';
                winScore.textContent = '';
                
                drawScore++;
                saveScores();
                updateScoreDisplay();
                
                winOverlay.style.display = 'flex';
            }
            
            // 放置棋子
            function placePiece(x, y, player) {
                if (gameOver || board[y][x] !== 0) return false;
                
                board[y][x] = player;
                drawPiece(x, y, player);
                
                // 播放落子音效
                playPieceSound();
                
                if (checkWin(x, y, player)) {
                    gameOver = true;
                    const winner = player === 1 ? '玩家' : '电脑';
                    setTimeout(() => showWinMessage(winner, player), 500);
                    return true;
                }
                
                // 检查平局
                if (checkDraw()) {
                    gameOver = true;
                    setTimeout(() => showDrawMessage(), 500);
                    return true;
                }
                
                return false;
            }
            
            // 检查是否获胜
            function checkWin(x, y, player) {
                const directions = [
                    [1, 0],   // 水平
                    [0, 1],    // 垂直
                    [1, 1],    // 对角线
                    [1, -1]    // 反对角线
                ];
                
                for (const [dx, dy] of directions) {
                    let count = 1;
                    
                    // 正向检查
                    for (let i = 1; i < 5; i++) {
                        const nx = x + i * dx;
                        const ny = y + i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }
                    
                    // 反向检查
                    for (let i = 1; i < 5; i++) {
                        const nx = x - i * dx;
                        const ny = y - i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }
                    
                    if (count >= 5) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // AI走棋
            function aiMove() {
                if (gameOver) return;
                
                // 简单AI逻辑：优先防守和进攻
                let bestScore = -Infinity;
                let bestMove = null;
                
                // 检查是否有立即获胜的机会
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (board[y][x] === 0) {
                            board[y][x] = 2;
                            if (checkWin(x, y, 2)) {
                                board[y][x] = 0;
                                bestMove = {x, y};
                                break;
                            }
                            board[y][x] = 0;
                        }
                    }
                    if (bestMove) break;
                }
                
                if (!bestMove) {
                    // 检查是否需要阻止玩家获胜
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x] === 0) {
                                board[y][x] = 1;
                                if (checkWin(x, y, 1)) {
                                    board[y][x] = 0;
                                    bestMove = {x, y};
                                    break;
                                }
                                board[y][x] = 0;
                            }
                        }
                        if (bestMove) break;
                    }
                }
                
                if (!bestMove) {
                    // 如果没有立即的威胁或机会，使用评分系统
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x] === 0) {
                                const score = evaluatePosition(x, y);
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMove = {x, y};
                                }
                            }
                        }
                    }
                }
                
                // 如果没有找到好的走法，随机选择一个空位
                if (!bestMove) {
                    const emptyCells = [];
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x] === 0) {
                                emptyCells.push({x, y});
                            }
                        }
                    }
                    if (emptyCells.length > 0) {
                        bestMove = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    }
                }
                
                if (bestMove) {
                    setTimeout(() => {
                        const {x, y} = bestMove;
                        if (placePiece(x, y, 2)) {
                            currentPlayerDisplay.textContent = '游戏结束';
                        } else {
                            currentPlayer = 1;
                            currentPlayerDisplay.textContent = '黑棋(玩家)';
                        }
                    }, 500);
                }
            }
            
            // 评估位置得分
            function evaluatePosition(x, y) {
                let score = 0;
                
                // 中心位置更有价值
                const centerX = BOARD_SIZE / 2;
                const centerY = BOARD_SIZE / 2;
                const distanceToCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                score += (BOARD_SIZE - distanceToCenter) * 0.5;
                
                // 检查四个方向
                const directions = [
                    [1, 0], [0, 1], [1, 1], [1, -1]
                ];
                
                for (const [dx, dy] of directions) {
                    // 检查AI的潜在连线
                    let aiCount = 1;
                    let aiOpenEnds = 0;
                    
                    // 正向检查
                    for (let i = 1; i < 5; i++) {
                        const nx = x + i * dx;
                        const ny = y + i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 2) {
                                aiCount++;
                            } else if (board[ny][nx] === 0) {
                                aiOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // 反向检查
                    for (let i = 1; i < 5; i++) {
                        const nx = x - i * dx;
                        const ny = y - i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 2) {
                                aiCount++;
                            } else if (board[ny][nx] === 0) {
                                aiOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // 根据连子数加分
                    if (aiCount >= 4) score += 10000;
                    else if (aiCount === 3 && aiOpenEnds >= 1) score += 1000;
                    else if (aiCount === 2 && aiOpenEnds >= 1) score += 100;
                    else if (aiCount === 1 && aiOpenEnds >= 1) score += 10;
                    
                    // 检查玩家的潜在连线
                    let playerCount = 0;
                    let playerOpenEnds = 0;
                    
                    // 正向检查
                    for (let i = 1; i < 5; i++) {
                        const nx = x + i * dx;
                        const ny = y + i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 1) {
                                playerCount++;
                            } else if (board[ny][nx] === 0) {
                                playerOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // 反向检查
                    for (let i = 1; i < 5; i++) {
                        const nx = x - i * dx;
                        const ny = y - i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 1) {
                                playerCount++;
                            } else if (board[ny][nx] === 0) {
                                playerOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // 根据玩家的连子数防守
                    if (playerCount >= 4) score += 5000;
                    else if (playerCount === 3 && playerOpenEnds >= 1) score += 500;
                    else if (playerCount === 2 && playerOpenEnds >= 1) score += 50;
                }
                
                return score;
            }
            
            // 重置游戏
            function resetGame() {
                board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
                gameMode = gameModeSelect.value;
                currentPlayer = gameMode === 'human-first' ? 1 : 2;
                gameOver = false;
                currentPlayerDisplay.textContent = currentPlayer === 1 ? '黑棋(玩家)' : '白棋(电脑)';
                winOverlay.style.display = 'none';
                initBoard();
                
                // 如果AI先手，让AI走第一步
                if (currentPlayer === 2) {
                    setTimeout(aiMove, 300);
                }
            }
            
            // 点击事件处理
            canvas.addEventListener('click', (e) => {
                if (gameOver || currentPlayer !== 1) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
                
                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                    if (placePiece(x, y, 1)) {
                        currentPlayerDisplay.textContent = '游戏结束';
                    } else {
                        currentPlayer = 2;
                        currentPlayerDisplay.textContent = '白棋(电脑)';
                        setTimeout(aiMove, 500);
                    }
                }
            });
            
            // 点击获胜弹窗外部关闭
            winOverlay.addEventListener('click', (e) => {
                if (e.target === winOverlay) {
                    winOverlay.style.display = 'none';
                }
            });
            
            // 事件监听器
            restartBtn.addEventListener('click', resetGame);
            resetScoreBtn.addEventListener('click', resetScores);
            musicBtn.addEventListener('click', toggleMusic);
            gameModeSelect.addEventListener('change', resetGame);
            
            // 初始化游戏
            updateScoreDisplay();
            resetGame();
        });
    </script>
</body>
</html>