<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹äººæœºå¯¹æˆ˜ - å»¶è¾¹ABCæ¸¸æˆåä¼š</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5dc;
            margin: 0;
            padding: 20px;
        }
        
        .association-header {
            font-size: 24px;
            color: #8B4513;
            margin-bottom: 5px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #8B4513;
            margin-top: 0;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        .game-info {
            margin-bottom: 20px;
            font-size: 18px;
            color: #333;
            background: rgba(255,255,255,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .score-board {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.8);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .score-item {
            text-align: center;
            font-size: 16px;
            color: #333;
        }
        
        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #8B4513;
            margin-top: 5px;
        }
        
        .board-container {
            position: relative;
            margin-bottom: 20px;
        }
        
        #board {
            background-color: #dcb35c;
            border: 3px solid #8B4513;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .button-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(to right, #8B4513, #A0522D);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
            font-weight: bold;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 8px rgba(0,0,0,0.3);
        }
        
        .music-btn {
            background: linear-gradient(to right, #4CAF50, #45a049);
        }
        
        .music-btn.playing {
            background: linear-gradient(to right, #f44336, #da190b);
        }
        
        .win-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .win-message {
            background: linear-gradient(135deg, #fff, #f0f0f0);
            padding: 40px 60px;
            border-radius: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #8B4513;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            border: 3px solid #8B4513;
            animation: winPopup 0.5s ease-out;
            max-width: 80%;
        }
        
        @keyframes winPopup {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .win-details {
            margin-top: 20px;
            font-size: 18px;
            color: #666;
        }
        
        .win-score {
            margin-top: 15px;
            font-size: 20px;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .mode-selector {
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        select {
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 30px;
            border: 2px solid #8B4513;
            background-color: white;
            cursor: pointer;
        }
        
        .association-footer {
            margin-top: 20px;
            font-size: 16px;
            color: #8B4513;
            font-style: italic;
        }
        
        .music-info {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- æ·»åŠ éŸ³é¢‘æ ‡ç­¾ï¼Œå‡è®¾éŸ³ä¹æ–‡ä»¶åä¸º background.mp3ï¼Œéœ€å°†å…¶æ”¾åœ¨é¡¹ç›®ç›®å½•ä¸‹ -->
    <audio id="background-music" src="background.mp3" loop autoplay></audio> 
    <div class="association-header">å»¶è¾¹ABCæ¸¸æˆåä¼š</div>
    <h1>äº”å­æ£‹äººæœºå¯¹æˆ˜</h1>
    
    <div class="mode-selector">
        <div>
            <select id="game-mode">
                <option value="human-first">ç©å®¶å…ˆæ‰‹(é»‘æ£‹)</option>
                <option value="ai-first">ç”µè„‘å…ˆæ‰‹(ç™½æ£‹)</option>
            </select>
        </div>
    </div>
    
    <div class="score-board">
        <div class="score-item">
            <div>ç©å®¶å¾—åˆ†</div>
            <div class="score-value" id="player-score">0</div>
        </div>
        <div class="score-item">
            <div>ç”µè„‘å¾—åˆ†</div>
            <div class="score-value" id="ai-score">0</div>
        </div>
        <div class="score-item">
            <div>å¹³å±€æ¬¡æ•°</div>
            <div class="score-value" id="draw-score">0</div>
        </div>
    </div>
    
    <div class="game-info">
        å½“å‰ç©å®¶: <span id="current-player">é»‘æ£‹</span>
    </div>
    
    <div class="board-container">
        <canvas id="board" width="450" height="450"></canvas>
    </div>
    
    <!-- è·èƒœå¼¹çª— -->
    <div class="win-overlay" id="win-overlay">
        <div class="win-message" id="win-message">
            <div id="win-text"></div>
            <div class="win-details" id="win-details"></div>
            <div class="win-score" id="win-score"></div>
        </div>
    </div>
    
    <div class="controls">
        <div class="button-row">
            <button id="restart-btn">é‡æ–°å¼€å§‹</button>
            <button id="music-btn" class="music-btn">ğŸµ æ’­æ”¾éŸ³ä¹</button>
            <button id="reset-score-btn">é‡ç½®åˆ†æ•°</button>
        </div>
        <div class="music-info">
            ç‚¹å‡»æŒ‰é’®æ§åˆ¶èƒŒæ™¯éŸ³ä¹æ’­æ”¾/æš‚åœ
        </div>
    </div>
    
    <div class="association-footer">å»¶è¾¹ABCæ¸¸æˆåä¼š è£èª‰å‡ºå“</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const currentPlayerDisplay = document.getElementById('current-player');
            const restartBtn = document.getElementById('restart-btn');
            const resetScoreBtn = document.getElementById('reset-score-btn');
            const musicBtn = document.getElementById('music-btn');
            const winOverlay = document.getElementById('win-overlay');
            const winText = document.getElementById('win-text');
            const winDetails = document.getElementById('win-details');
            const winScore = document.getElementById('win-score');
            const gameModeSelect = document.getElementById('game-mode');
            
            // è®¡åˆ†å…ƒç´ 
            const playerScoreElement = document.getElementById('player-score');
            const aiScoreElement = document.getElementById('ai-score');
            const drawScoreElement = document.getElementById('draw-score');
            
            // éŸ³é¢‘å…ƒç´ 
            const backgroundMusic = document.getElementById('background-music');
            const pieceSound = document.getElementById('piece-sound');
            const winSound = document.getElementById('win-sound');
            
            const BOARD_SIZE = 15;
            const CELL_SIZE = canvas.width / BOARD_SIZE;
            const PIECE_RADIUS = CELL_SIZE * 0.4;
            
            let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            let currentPlayer = 1; // 1 for black (human), 2 for white (AI)
            let gameOver = false;
            let gameMode = 'human-first';
            let musicPlaying = false;
            
            // è®¡åˆ†ç³»ç»Ÿ
            let playerScore = parseInt(localStorage.getItem('playerScore')) || 0;
            let aiScore = parseInt(localStorage.getItem('aiScore')) || 0;
            let drawScore = parseInt(localStorage.getItem('drawScore')) || 0;
            
            // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
            function updateScoreDisplay() {
                playerScoreElement.textContent = playerScore;
                aiScoreElement.textContent = aiScore;
                drawScoreElement.textContent = drawScore;
            }
            
            // ä¿å­˜åˆ†æ•°åˆ°æœ¬åœ°å­˜å‚¨
            function saveScores() {
                localStorage.setItem('playerScore', playerScore);
                localStorage.setItem('aiScore', aiScore);
                localStorage.setItem('drawScore', drawScore);
            }
            
            // é‡ç½®åˆ†æ•°
            function resetScores() {
                playerScore = 0;
                aiScore = 0;
                drawScore = 0;
                updateScoreDisplay();
                saveScores();
            }
            
            // éŸ³ä¹æ§åˆ¶
            function toggleMusic() {
                if (musicPlaying) {
                    backgroundMusic.pause();
                    musicBtn.textContent = 'ğŸµ æ’­æ”¾éŸ³ä¹';
                    musicBtn.classList.remove('playing');
                    musicPlaying = false;
                } else {
                    // åˆ›å»ºç®€å•çš„éŸ³è°ƒä½œä¸ºèƒŒæ™¯éŸ³ä¹
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime + 0.5);
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 1);
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 1.5);
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 2);
                    
                    musicBtn.textContent = 'ğŸ”‡ æš‚åœéŸ³ä¹';
                    musicBtn.classList.add('playing');
                    musicPlaying = true;
                }
            }
            
            // æ’­æ”¾è½å­éŸ³æ•ˆ
            function playPieceSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e);
                }
            }
            
            // æ’­æ”¾è·èƒœéŸ³æ•ˆ
            function playWinSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // æ’­æ”¾èƒœåˆ©éŸ³è°ƒ
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.4);
                    oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime + 0.6);
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.6);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.8);
                } catch (e) {
                    console.log('è·èƒœéŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e);
                }
            }
            
            // åˆå§‹åŒ–æ£‹ç›˜
            function initBoard() {
                // ç»˜åˆ¶æ£‹ç›˜èƒŒæ™¯
                ctx.fillStyle = '#dcb35c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // æ¨ªçº¿
                    ctx.beginPath();
                    ctx.moveTo(CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                    ctx.lineTo(canvas.width - CELL_SIZE / 2, i * CELL_SIZE + CELL_SIZE / 2);
                    ctx.stroke();
                    
                    // ç«–çº¿
                    ctx.beginPath();
                    ctx.moveTo(i * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 2);
                    ctx.lineTo(i * CELL_SIZE + CELL_SIZE / 2, canvas.height - CELL_SIZE / 2);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶äº”ä¸ªå°ç‚¹ï¼ˆå¤©å…ƒç­‰ï¼‰
                const dots = [
                    [3, 3], [3, 11], [7, 7], [11, 3], [11, 11]
                ];
                
                ctx.fillStyle = '#000';
                dots.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(
                        x * CELL_SIZE + CELL_SIZE / 2,
                        y * CELL_SIZE + CELL_SIZE / 2,
                        CELL_SIZE * 0.1,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }
            
            // ç»˜åˆ¶æ£‹å­
            function drawPiece(x, y, player) {
                const gradient = ctx.createRadialGradient(
                    x * CELL_SIZE + CELL_SIZE / 2 - PIECE_RADIUS / 3,
                    y * CELL_SIZE + CELL_SIZE / 2 - PIECE_RADIUS / 3,
                    PIECE_RADIUS * 0.1,
                    x * CELL_SIZE + CELL_SIZE / 2,
                    y * CELL_SIZE + CELL_SIZE / 2,
                    PIECE_RADIUS
                );
                
                if (player === 1) { // é»‘æ£‹
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#000');
                } else { // ç™½æ£‹
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(1, '#ddd');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(
                    x * CELL_SIZE + CELL_SIZE / 2,
                    y * CELL_SIZE + CELL_SIZE / 2,
                    PIECE_RADIUS,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // æ£‹å­è¾¹ç¼˜
                ctx.strokeStyle = player === 1 ? '#333' : '#999';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // æ£€æŸ¥æ˜¯å¦å¹³å±€
            function checkDraw() {
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (board[y][x] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // æ˜¾ç¤ºè·èƒœä¿¡æ¯
            function showWinMessage(winner, player) {
                winText.textContent = `${winner}è·èƒœï¼`;
                winDetails.textContent = player === 1 ? 'æ­å–œç©å®¶è·å¾—èƒœåˆ©ï¼' : 'ç”µè„‘æŠ€é«˜ä¸€ç­¹ï¼';
                
                // æ›´æ–°åˆ†æ•°
                if (player === 1) {
                    playerScore++;
                    winScore.textContent = `ç©å®¶å¾—åˆ†: ${playerScore}`;
                } else {
                    aiScore++;
                    winScore.textContent = `ç”µè„‘å¾—åˆ†: ${aiScore}`;
                }
                
                saveScores();
                updateScoreDisplay();
                
                winOverlay.style.display = 'flex';
                
                // æ’­æ”¾è·èƒœéŸ³æ•ˆ
                playWinSound();
            }
            
            // æ˜¾ç¤ºå¹³å±€ä¿¡æ¯
            function showDrawMessage() {
                winText.textContent = 'å¹³å±€ï¼';
                winDetails.textContent = 'æ£‹é€¢å¯¹æ‰‹ï¼ŒåŠ¿å‡åŠ›æ•Œï¼';
                winScore.textContent = '';
                
                drawScore++;
                saveScores();
                updateScoreDisplay();
                
                winOverlay.style.display = 'flex';
            }
            
            // æ”¾ç½®æ£‹å­
            function placePiece(x, y, player) {
                if (gameOver || board[y][x] !== 0) return false;
                
                board[y][x] = player;
                drawPiece(x, y, player);
                
                // æ’­æ”¾è½å­éŸ³æ•ˆ
                playPieceSound();
                
                if (checkWin(x, y, player)) {
                    gameOver = true;
                    const winner = player === 1 ? 'ç©å®¶' : 'ç”µè„‘';
                    setTimeout(() => showWinMessage(winner, player), 500);
                    return true;
                }
                
                // æ£€æŸ¥å¹³å±€
                if (checkDraw()) {
                    gameOver = true;
                    setTimeout(() => showDrawMessage(), 500);
                    return true;
                }
                
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦è·èƒœ
            function checkWin(x, y, player) {
                const directions = [
                    [1, 0],   // æ°´å¹³
                    [0, 1],    // å‚ç›´
                    [1, 1],    // å¯¹è§’çº¿
                    [1, -1]    // åå¯¹è§’çº¿
                ];
                
                for (const [dx, dy] of directions) {
                    let count = 1;
                    
                    // æ­£å‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x + i * dx;
                        const ny = y + i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }
                    
                    // åå‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x - i * dx;
                        const ny = y - i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }
                    
                    if (count >= 5) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // AIèµ°æ£‹
            function aiMove() {
                if (gameOver) return;
                
                // ç®€å•AIé€»è¾‘ï¼šä¼˜å…ˆé˜²å®ˆå’Œè¿›æ”»
                let bestScore = -Infinity;
                let bestMove = null;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ç«‹å³è·èƒœçš„æœºä¼š
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (board[y][x] === 0) {
                            board[y][x] = 2;
                            if (checkWin(x, y, 2)) {
                                board[y][x] = 0;
                                bestMove = {x, y};
                                break;
                            }
                            board[y][x] = 0;
                        }
                    }
                    if (bestMove) break;
                }
                
                if (!bestMove) {
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦é˜»æ­¢ç©å®¶è·èƒœ
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x] === 0) {
                                board[y][x] = 1;
                                if (checkWin(x, y, 1)) {
                                    board[y][x] = 0;
                                    bestMove = {x, y};
                                    break;
                                }
                                board[y][x] = 0;
                            }
                        }
                        if (bestMove) break;
                    }
                }
                
                if (!bestMove) {
                    // å¦‚æœæ²¡æœ‰ç«‹å³çš„å¨èƒæˆ–æœºä¼šï¼Œä½¿ç”¨è¯„åˆ†ç³»ç»Ÿ
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x] === 0) {
                                const score = evaluatePosition(x, y);
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMove = {x, y};
                                }
                            }
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¥½çš„èµ°æ³•ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªç©ºä½
                if (!bestMove) {
                    const emptyCells = [];
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x] === 0) {
                                emptyCells.push({x, y});
                            }
                        }
                    }
                    if (emptyCells.length > 0) {
                        bestMove = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    }
                }
                
                if (bestMove) {
                    setTimeout(() => {
                        const {x, y} = bestMove;
                        if (placePiece(x, y, 2)) {
                            currentPlayerDisplay.textContent = 'æ¸¸æˆç»“æŸ';
                        } else {
                            currentPlayer = 1;
                            currentPlayerDisplay.textContent = 'é»‘æ£‹(ç©å®¶)';
                        }
                    }, 500);
                }
            }
            
            // è¯„ä¼°ä½ç½®å¾—åˆ†
            function evaluatePosition(x, y) {
                let score = 0;
                
                // ä¸­å¿ƒä½ç½®æ›´æœ‰ä»·å€¼
                const centerX = BOARD_SIZE / 2;
                const centerY = BOARD_SIZE / 2;
                const distanceToCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                score += (BOARD_SIZE - distanceToCenter) * 0.5;
                
                // æ£€æŸ¥å››ä¸ªæ–¹å‘
                const directions = [
                    [1, 0], [0, 1], [1, 1], [1, -1]
                ];
                
                for (const [dx, dy] of directions) {
                    // æ£€æŸ¥AIçš„æ½œåœ¨è¿çº¿
                    let aiCount = 1;
                    let aiOpenEnds = 0;
                    
                    // æ­£å‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x + i * dx;
                        const ny = y + i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 2) {
                                aiCount++;
                            } else if (board[ny][nx] === 0) {
                                aiOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // åå‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x - i * dx;
                        const ny = y - i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 2) {
                                aiCount++;
                            } else if (board[ny][nx] === 0) {
                                aiOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // æ ¹æ®è¿å­æ•°åŠ åˆ†
                    if (aiCount >= 4) score += 10000;
                    else if (aiCount === 3 && aiOpenEnds >= 1) score += 1000;
                    else if (aiCount === 2 && aiOpenEnds >= 1) score += 100;
                    else if (aiCount === 1 && aiOpenEnds >= 1) score += 10;
                    
                    // æ£€æŸ¥ç©å®¶çš„æ½œåœ¨è¿çº¿
                    let playerCount = 0;
                    let playerOpenEnds = 0;
                    
                    // æ­£å‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x + i * dx;
                        const ny = y + i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 1) {
                                playerCount++;
                            } else if (board[ny][nx] === 0) {
                                playerOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // åå‘æ£€æŸ¥
                    for (let i = 1; i < 5; i++) {
                        const nx = x - i * dx;
                        const ny = y - i * dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                            if (board[ny][nx] === 1) {
                                playerCount++;
                            } else if (board[ny][nx] === 0) {
                                playerOpenEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // æ ¹æ®ç©å®¶çš„è¿å­æ•°é˜²å®ˆ
                    if (playerCount >= 4) score += 5000;
                    else if (playerCount === 3 && playerOpenEnds >= 1) score += 500;
                    else if (playerCount === 2 && playerOpenEnds >= 1) score += 50;
                }
                
                return score;
            }
            
            // é‡ç½®æ¸¸æˆ
            function resetGame() {
                board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
                gameMode = gameModeSelect.value;
                currentPlayer = gameMode === 'human-first' ? 1 : 2;
                gameOver = false;
                currentPlayerDisplay.textContent = currentPlayer === 1 ? 'é»‘æ£‹(ç©å®¶)' : 'ç™½æ£‹(ç”µè„‘)';
                winOverlay.style.display = 'none';
                initBoard();
                
                // å¦‚æœAIå…ˆæ‰‹ï¼Œè®©AIèµ°ç¬¬ä¸€æ­¥
                if (currentPlayer === 2) {
                    setTimeout(aiMove, 300);
                }
            }
            
            // ç‚¹å‡»äº‹ä»¶å¤„ç†
            canvas.addEventListener('click', (e) => {
                if (gameOver || currentPlayer !== 1) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
                
                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                    if (placePiece(x, y, 1)) {
                        currentPlayerDisplay.textContent = 'æ¸¸æˆç»“æŸ';
                    } else {
                        currentPlayer = 2;
                        currentPlayerDisplay.textContent = 'ç™½æ£‹(ç”µè„‘)';
                        setTimeout(aiMove, 500);
                    }
                }
            });
            
            // ç‚¹å‡»è·èƒœå¼¹çª—å¤–éƒ¨å…³é—­
            winOverlay.addEventListener('click', (e) => {
                if (e.target === winOverlay) {
                    winOverlay.style.display = 'none';
                }
            });
            
            // äº‹ä»¶ç›‘å¬å™¨
            restartBtn.addEventListener('click', resetGame);
            resetScoreBtn.addEventListener('click', resetScores);
            musicBtn.addEventListener('click', toggleMusic);
            gameModeSelect.addEventListener('change', resetGame);
            
            // åˆå§‹åŒ–æ¸¸æˆ
            updateScoreDisplay();
            resetGame();
        });
    </script>
</body>
</html>